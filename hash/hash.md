# 哈希函数

#### 什么是哈希函数 ：

	1.  输入域是无穷的，但是输出域是有范围的
 	2.  输入值对应唯一的输出值，说明hash函数中不存在随机因子
 	3.  不同的输入值，也有可能会导致相同的输出结果，这种情况叫做hash碰撞

#### hash函数的特性：

最重要的性质：离散型和均匀性很好，就是对于无穷的输入，即使输入的值相差不多，hash函数也会将hash值离散到各个位置，保证在有限的输出区域，每个小区域中包含的值的个数是差不多的。

#### hash函数的使用案例

案例，当需要在40亿个数据中找到出现次数最多的数字，并且只给定2G的内存进行查找？

案例分析：40亿个数据，如果使用hash表的话，至少是需要32G的内存进行操作，此时需要使用hash函数的性质进行操作，获取40亿个数据的hash值，然后将hash值%100，按照hash函数的性质，会将40亿个数据大致均分到100个文件中，然后分别统计100个文件中出现次数最多的数据，其中每份文件仅占用0.32G，内存不会爆掉！





# 哈希表

#### 哈希表概念和特性

特性：**CRUD的时间复杂度都是O(logN）,但是可以在使用的使用逼近O(1)**

#### java中hashmap实现的原理

1. java中hashmap的默认数组长度是16, 负载因子是0.75
2. 当一个数插入到hashmap中的时候，会计算key的hash值，确认key存放的位置，如果该位置之前没有值的话，则直接插入，有值，判断是红黑树还是链表，然后调用对应的插入数据的规则进行插入
3. 如果链表的长度超过了8的时候，会触发hashmap的扩容规则，首先判断数组的长度是否已经超过了64,如果没有超过64的话，则对数组进行扩容，数组扩容的(大小为16*负载因子0.75=12，如果数组的长度超过64的话就会将链表转换为红黑树。

#### 哈新表的时间复杂度

将1000个数加到hash表，如果链表长度超过2就进行扩容，因为hash表的负载因子是2,所以最差的情况进行1000个数字都在数组上，那么需要多少次扩容才能将1000个数字全部放在数组上呢2^n=10000,n=log2^10000，所以扩容的时间复杂度是O(logN),扩容的时候每个数字都需要重新计算hash值，所以N个数字进行扩容的话时间复杂度是O(N*logN),单次扩容的时间复杂度的是O(logN)，那为什么说hash表的crud是趋近O(1)呢，因为可以把数组的长度设置为一个比较小的数，此时logn^m中，n的数比较小，m比较大，数字大小会比较趋近于一个常数，所以此时可以认定为hash表的时间CRUD的时间复杂度趋近与O(1),同时在实际使用的过程中，hash表还用删除等操作，不会频繁触发扩容，并且在java等技术中采用的是离线扩容的技术的，所以扩容的时候是不占用时间的，**所以hash表在理论情况下的时间复杂度是O(logN)，实际上的时间复杂度趋近于O(1)**

#### 案例

![image-20220430174315248](C:\Users\19586\AppData\Roaming\Typora\typora-user-images\image-20220430174315248.png)

![image-20220503061101513](C:\Users\19586\AppData\Roaming\Typora\typora-user-images\image-20220503061101513.png)



# 布隆过滤器

#### 布隆过滤器的使用场景

在实际生产生活中，如果我们需要去一个大量的数据中进行查找我们所需要的结果，比如黑名单需求，需要在一亿个url中确定我们的url是否合法，如果全部将所有的url加入到内存中的话，可能会导致内存爆掉，如果使用hash表，将对应的数据分批存储到不同的文件，然后在不同的文件中进行查询比较的话，所需要的时间会比较多，而**布隆过滤器作为一个可以极大减少查询大数据量所需要的空间，但是会存在一定的误报率，即将不是黑名单中的url进行误判，但是误判率是可以进行控制的**



#### 布隆过滤器的实现

布隆过滤器是基于位图进行实现的，什么是位图，可以理解为是一个数据类型，但是这个数据类型只占用1个bit，这种数据类型的集合叫做位图，比如int[10]，int占用4个字节，该数据结构占用的是320个bit,而位图只占用80个bit。

**那么位图如何进行实现呢？**

 可以通过基础数据类型，比如int进行位运算得到.

**布隆过滤器的实现原理是什么呢？**

假设我有100亿个url，我有长度为m的位图数组，我有k个hash函数，此时我依次从100亿个url集合中获取到对应的url，拿到url后对其分别调用k个hash函数-->%m的到在位图上的位置，然后将该位置进行描黑，循环100亿次后，位图m中会有一部分区域是黑色的，然后我需要查询url是否在黑名单的时候,此时将我的url进行调用k个hash函数,然后调用%m,得到的结果全为1的话，证明我的url在黑名单中。反之则不在

**布隆过滤器误判的原因**

由于hash函数的特性，固定的输入就会有固定的输出，即不存在随机因子的特性，如果url在位图中的话，一定是会被检测在位图当中的。然后当m比较小，样本数量比较大的时候，可能会将位图全部描黑，此时如果有不在黑名单中的url也有可能会被误判，所有误判率取决于位图的长度，所以在设计布隆过滤器的时候，我们需要研究其m的长度，然后根据m的长度制定k个hash函数。

